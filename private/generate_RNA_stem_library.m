function generate_RNA_stem_library(istrand1,estrand1)
% function generate_RNA_stem_library
%
% uses a set of RNA segment PDB files and
% creates a library of stem segments
% user is prompted for identifying the files
%
% istrand1  flag, if true, the nucleotide for start attachment is the first
%           nt of the first strand, if false, it is the first nt of the
%           second strand
% estrand1  flag, if true, the nucleotide for end attachment is the last nt
%           of the first strand, if false, it is the last nt of the second
%           strand

%
% the library is for later use in RigiFlex and contains
%   a paradigm PDB file (for the first entry)
%   coordinate sets for the other entries
%
% the set of RNA segment PDB files can be generated by the Rosetta server
% Rosie FarFar: http://rosie.graylab.jhu.edu/documentation/rna_denovo
%
% all PDB files of the RNA segments must be in the same directory and this
% directory must not contain any other file with extension .pdb
%
% made from a Rosie FarFar output with S stem models
% for the first and last nucleotide, all library fragments are found 
% (based on shortfrag) that are superimposable with the first two (i,i+1) 
% /last two (j-1, j) nucleotides and the corresponding C4'(i-1) or P(j+1) 
% coordinate is stored
% stems		struct vector with S elements and fields
%		.ecoor 		full atom coordinates (n x 4 double), where
% 				the first column is relative nucleotide index
% 				and columns 2:4 the coordinates
%		.ptransmat	affine transformation matrices from standard 
%				fragment frame to C5'-terminal anchor frame, 
% 				cell vector for p allowed fragments
%		.htransmat	affine transformation matrices from standard 
%				fragment frame to local frame of the last nucleotide of the 
%               first strand 
% 				cell vector for p allowed fragments
%		.ntransmat	affine transformation matrix from standard 
%				fragment frame to C3'-terminal anchor frame
%		.previous	vector of p fragment library indices of 
% 				allowed i-1 fragments
%		.prev_coor	array (p x 3 double) of C4'(i-1) coordinates 
% 				for preceding fragment
%		.next		vector of p fragment library indices of 
% 				allowed j+1 fragments
%		.next_coor	array (p x 3 double) of P(j+1) coordinates 
% 				for next fragment
%		.ptaf		pseudo-torsion atom coordinates of first 
% 				residue, P(i), C4'(i), P(i+1)
%       .ptah       pseudo-torsion atom coordinates of last residue of
%                   first strand
%		.ptal		pseudo-torsion atom coordinates of last 
% 				residue, C4'(j-1), P(j), C4'(j)
%       .ifragment   fragment index (best fit) for initial nt
%       .efragment   fragment index (best fit) for final nt
% stem_def	.ntf 		base code of first nucleotide
%		.ntl 		base code of last nucleotide
%       .seq        sequence
%		.atomtags	n-member cell array of atom tags
%
% G. Jeschke, 26.12.2017

global model

mydir = pwd;
[fname,pname]=uigetfile('*.pdb','Select paradigm RNA segment PDB file');
if isequal(fname,0) || isequal(pname,0)
    add_msg_board('RNA stem library generation cancelled by user');
    return
else
    [msg,snum] = add_pdb(fullfile(pname,fname));
    if msg.error
        add_msg_board(sprintf('ERROR in reading paradigm PDB file: %s. Aborting.',msg.text));
        return
    end
    cd(pname);
    if ~exist('sel','var') || isempty(sel)
        RNA_list = dir('*.pdb');
    else
        for ks = 1:length(sel)
            mtag = sprintf('%i',sel(ks));
            preamb = 'R_000000';
            RNA_list(ks).name = sprintf('%s%s.pdb',preamb(1:8-length(mtag)),mtag);
        end
    end
end

set(gcf,'Pointer','watch');

libtype = [0,0];
if istrand1
    libtype(1) = 1;
else
    libtype(1) = 2;
end
if estrand1
    libtype(2) = 1;
else
    libtype(2) = 2;
end

ndecoys = length(RNA_list);
[atnum,~] = size(model.structures{snum}(1).xyz{1});
stems(1).ecoor = zeros(atnum,4);
stems(1).ecoor(:,2:4) = model.structures{snum}(1).xyz{1};
stem_def.ntf = upper(model.structures{snum}(1).sequence(1));
ntnum = length(model.structures{snum}(1).sequence);
stem_def.ntl = upper(model.structures{snum}(1).sequence(ntnum));
stem_def.seq = upper(model.structures{snum}(1).sequence);
stem_def.length = floor(ntnum/2);
stem_def.atomtags = cell(1,atnum);
stem_def.libtype = libtype;
poi = 0;
for knt = 1:ntnum
    atags =  model.structures{snum}(1).residues{1}.info(knt).atom_tags;
    atag = '?';
    apoi = 0;
    while ~isempty(atag)
        apoi = apoi + 1;
        atag = id2tag(apoi,atags);
        if ~isempty(atag)
            poi = poi + 1;
            stem_def.atomtags{poi} = atag;
            stems(1).ecoor(poi,1) = knt;
        end
    end
end

if poi ~= atnum
    fprintf(2,'Warning: Atom number mismatch %i,%i.\n',poi,atnum);
end

load nuclib_5

stem = analyze_RNA_links(snum,shortfrag,1,fragments,istrand1,estrand1);
stems(1).previous = stem.previous;
stems(1).prev_coor = stem.prev_coor;
stems(1).next = stem.next;
stems(1).next_P = stem.next_P;
stems(1).next_C4p = stem.next_C4p;
stems(1).ptaf = stem.ptaf;
stems(1).ptal = stem.ptal;
stems(1).ptransmat = stem.ptransmat;
stems(1).ntransmat = stem.ntransmat;
stems(1).ifragment = stem.ifragment;
stems(1).efragment = stem.efragment;


tic,
for kd = 2:ndecoys
    [msg,snum] = add_pdb(RNA_list(kd).name);
    if msg.error
        add_msg_board(sprintf('ERROR: PDB file %s could not be read (%s). Aborting.',RNA_list(kd).name,msg.text));
        cd(mydir);
        set(gcf,'Pointer','arrow');
        return
    end
    stems(kd).ecoor = zeros(atnum,4);
    stems(kd).ecoor(:,1) = stems(1).ecoor(:,1);
    stems(kd).ecoor(:,2:4) = model.structures{snum}(1).xyz{1};
    stem = analyze_RNA_links(snum,shortfrag,1,fragments,istrand1,estrand1);
    stems(kd).previous = stem.previous;
    stems(kd).prev_coor = stem.prev_coor;
    stems(kd).next = stem.next;
    stems(kd).next_P = stem.next_P;
    stems(kd).next_C4p = stem.next_C4p;
    stems(kd).ptaf = stem.ptaf;
    stems(kd).ptal = stem.ptal;
    stems(kd).ptransmat = stem.ptransmat;
    stems(kd).ntransmat = stem.ntransmat;
    stems(kd).efragment = stem.efragment;
    stems(kd).ifragment = stem.ifragment;
end
% toc,
set(gcf,'Pointer','arrow');

% disp('Finished');

defname = 'stem_lib.mat';
[filename, pathname] = uiputfile(defname, 'Save stem library in MMM format');
if isequal(filename,0) || isequal(pathname,0)
    message.text='Saving of stem library cancelled by user';
    message.error=1;
else
    fname=fullfile(pathname, filename);
    msg=sprintf('Stem library saved as: %s',fname);
    add_msg_board(msg);
    save(fname,'stem_def','stems');
end


